#include <cupy/carray.cuh>
#include <cub/cub.cuh>

{%- macro create_arg(name, type, dims, input=True) -%}
{%- if input %}const{% endif %} CArray<{{type}}, {{dims}}> {{name}}
{%- endmacro -%}

{#- Construct the kernel argument list #}
{%- set kernel_args = [
    create_arg("time_index", "int", 1),
    create_arg("antenna1", "int", 1),
    create_arg("antenna2", "int", 1) ] -%}

{%- if have_dde1 %}
{%- do kernel_args.append(create_arg("dde1", dde1_type, dde1_ndim)) %}
{%- endif %}
{%- if have_coh %}
{%- do kernel_args.append(create_arg("source_coh", coh_type, coh_ndim)) %}
{%- endif %}
{%- if have_dde2 %}
{%- do kernel_args.append(create_arg("dde2", dde2_type, dde2_ndim)) %}
{%- endif %}
{%- if have_die1 %}
{%- do kernel_args.append(create_arg("die1", die1_type, die1_ndim)) %}
{%- endif %}
{%- if have_base_vis %}
{%- do kernel_args.append(create_arg("base_vis", base_vis_type, base_vis_ndim)) %}
{%- endif %}
{%- if have_die2 %}
{%- do kernel_args.append(create_arg("die2", die2_type, die2_ndim)) %}
{%- endif %}

{%- do kernel_args.append(create_arg("output", out_type, out_ndim, False)) %}
{# End kernel argument list construction #}


{%- set have_ddes = have_dde1 and have_dde2 %}
{%- set have_dies = have_die1 and have_die2 %}

{#- Determine nrow and nchan variables #}
{%- if have_ddes %}
{%- set ntime = "dde1.shape()[1]" %}
{%- set na = "dde1.shape()[2]" %}
{%- set nchan = "dde1.shape()[3]" %}
{%- elif have_dies %}
{%- set ntime = "die1.shape()[0]" %}
{%- set na = "die1.shape()[1]" %}
{%- set nchan = "die1.shape()[2]" %}
{%- elif have_coh %}
{%- set nchan = "source_coh.shape()[2]" %}
{%- endif %}
{%- set nrow = "time_index.shape()[0]" %}
{#- end nrow and nchan variable determination #}

{#- Determine nsrc variable #}
{%- set do_coherencies = have_ddes or have_coh %}
{%- if have_ddes %}
{%- set nsrc = "dde1.shape()[0]" %}
{%- elif have_coh %}
{%- set nsrc = "source_coh.shape()[0]" %}
{%- endif %}
{#- End nsrc variable determination #}

#define WARP_STRIPED false

// Create BlockExchange algorithm types
{%- if have_dde1 %}
typedef cub::BlockExchange<{{dde1_type}}, {{blockdimx}}, {{corrs}},
                           WARP_STRIPED, {{blockdimy}}> BlockExchangeDDE1;
{%- endif %}

{%- if have_coh %}
typedef cub::BlockExchange<{{coh_type}}, {{blockdimx}}, {{corrs}},
                           WARP_STRIPED, {{blockdimy}}> BlockExchangeCOH;
{%- endif %}

{%- if have_dde2 %}
typedef cub::BlockExchange<{{dde2_type}}, {{blockdimx}}, {{corrs}},
                           WARP_STRIPED, {{blockdimy}}> BlockExchangeDDE2;
{%- endif %}

{%- if have_die1 %}
typedef cub::BlockExchange<{{die1_type}}, {{blockdimx}}, {{corrs}},
                           WARP_STRIPED, {{blockdimy}}> BlockExchangeDIE1;
{%- endif %}

{%- if have_base_vis %}
typedef cub::BlockExchange<{{base_vis_type}}, {{blockdimx}}, {{corrs}},
                           WARP_STRIPED, {{blockdimy}}> BlockExchangeBVIS;
{%- endif %}

{%- if have_die2 %}
typedef cub::BlockExchange<{{die1_type}}, {{blockdimx}}, {{corrs}},
                           WARP_STRIPED, {{blockdimy}}> BlockExchangeDIE2;
{%- endif %}



// Warp Striped Load of Correlation Data
template <typename InputT,
          int CORRS_PER_THREAD,
          typename InputIteratorT>
__device__ __forceinline__ void
CorrLoad(InputIteratorT input,
         unsigned int N,
         unsigned int offset,
         InputT (&corrs)[CORRS_PER_THREAD])
{
    #pragma unroll
    for(int CORR=0; CORR < CORRS_PER_THREAD; ++CORR)
        { corrs[CORR] = input[N*CORR + offset]; }
}

extern "C" __global__ void {{kernel_name}}(
{{kernel_args|join(",\n")}}
)
{
    using namespace cub;

    int row = blockDim.y*blockIdx.y + threadIdx.y;
    int chan = blockDim.x*blockIdx.x + threadIdx.x;

    // Guard
    // row >= nrow || chan >= nchan
    if(row >= {{nrow}} || chan >= {{nchan}})
        { return; }

    // Shared memory (unioned) for exchanges
    __shared__ union {
        {%- if have_dde1 %}
        typename BlockExchangeDDE1::TempStorage dde1;
        {%- endif %}

        {%- if have_coh %}
        typename BlockExchangeCOH::TempStorage coh;
        {%- endif %}

        {%- if have_dde2 %}
        typename BlockExchangeDDE2::TempStorage dde2;
        {%- endif %}

        {%- if have_die1 %}
        typename BlockExchangeDIE1::TempStorage die1;
        {%- endif %}

        {%- if have_base_vis %}
        typename BlockExchangeBVIS::TempStorage bvis;
        {%- endif %}

        {%- if have_die2 %}
        typename BlockExchangeDIE2::TempStorage die2;
        {%- endif %}
    } shared;

    int ti = time_index[row];
    int ant1 = antenna1[row];
    int ant2 = antenna2[row];

    // Declare and initialise result
    {{out_type}} vis[{{corrs}}];
    {%- for c in range(corrs) %}
    vis[{{c}}] = make_{{out_type}}(0, 0);
    {%- endfor %}

    {% if do_coherencies %}
    // Loop over nsrc
    for(int src=0; src < {{nsrc}}; ++src)
    {
        {{out_type}} scratch[{{corrs}}];

        {%- if have_ddes %}
        {
            // Load in second direction dependent effect term
            {{dde2_type}} data[{{corrs}}];
            CorrLoad(&dde2[0], {{nsrc}}*{{ntime}}*{{na}}*{{nchan}},
                     ((src*{{ntime}} + ti)*{{na}} + ant2)*{{nchan}} + chan,
                     data);
            BlockExchangeDDE2(shared.dde2).WarpStripedToBlocked(data, data);
            __syncthreads();
        }
        {%- endif %}

        {%- if have_coh %}
        {
            {{coh_type}} data[{{corrs}}];
            CorrLoad(&source_coh[0], {{nsrc}}*{{nrow}}*{{nchan}},
                     ((src*{{nrow}} + row)*{{nchan}}) + chan,
                     data);
            BlockExchangeCOH(shared.coh).WarpStripedToBlocked(data, data);
            __syncthreads();
        }
        {%- endif %}

        {%- if have_ddes %}
        {
            // Load in first direction dependent effect term
            {{dde1_type}} data[{{corrs}}];
            CorrLoad(&dde1[0], {{nsrc}}*{{ntime}}*{{na}}*{{nchan}},
                     ((src*{{ntime}} + ti)*{{na}} + ant1)*{{nchan}} + chan,
                     data);
            BlockExchangeDDE1(shared.dde1).WarpStripedToBlocked(data, data);
            __syncthreads();
        }
        {%- endif %}

        // Add in contributions from this source correlation
        #pragma unroll
        for(int CORR=0; CORR < {{corrs}}; ++CORR)
            { vis[CORR].x += scratch[CORR].x; vis[CORR].y += scratch[CORR].y; }

    }
    {%- endif %}

    {%- if have_dies %}
    {
        // Load in second direction dependent effect term
        {{die2_type}} data[{{corrs}}];
        CorrLoad(&die2[0], {{ntime}}*{{na}}*{{nchan}},
                 (ti*{{na}} + ant2)*{{nchan}} + chan,
                 data);

        BlockExchangeDIE2(shared.die2).WarpStripedToBlocked(data, data);
        __syncthreads();
    }
    {%- endif %}

    {%- if have_base_vis %}
    {
        {{base_vis_type}} data[{{corrs}}];
        // Load in base visibility term
        CorrLoad(&base_vis[0], {{nrow}}*{{nchan}},
                 row*{{nchan}} + chan,
                 data);

        BlockExchangeBVIS(shared.bvis).WarpStripedToBlocked(data, data);
        __syncthreads();
    }
    {%- endif %}

    {%- if have_dies %}
    {
        // Load in first direction dependent effect term
        {{die1_type}} data[{{corrs}}];
        CorrLoad(&die1[0], {{ntime}}*{{na}}*{{nchan}},
                 (ti*{{na}} + ant1)*{{nchan}} + chan,
                 data);

        BlockExchangeDIE1(shared.die1).WarpStripedToBlocked(data, data);
        __syncthreads();
    }
    {%- endif %}
}

// jinja2 parameters
// dde1: {{have_dde1}} {{dde1_type}} {{dde1_ndim}}
// source_coh: {{have_coh}} {{coh_type}} {{coh_ndim}}
// have_ddes2 = {{have_dde2}}
// have_dies1 = {{have_die1}}
// have_base_vis = {{have_base_vis}}
// have_dies2 = {{have_die2}}
