#include <cupy/carray.cuh>
#include <trove/block.h>

{%- macro create_arg(name, type, dims, input=True) -%}
{%- if input %}const{% endif %} CArray<{{type}}, {{dims}}> {{name}}
{%- endmacro -%}

{#- Construct the kernel argument list #}
{%- set kernel_args = [
    create_arg("time_index", "int", 1),
    create_arg("antenna1", "int", 1),
    create_arg("antenna2", "int", 1) ] -%}

{%- if have_dde1 %}
{%- do kernel_args.append(create_arg("dde1", dde1_type, dde1_ndim)) %}
{%- endif %}
{%- if have_coh %}
{%- do kernel_args.append(create_arg("source_coh", coh_type, coh_ndim)) %}
{%- endif %}
{%- if have_dde2 %}
{%- do kernel_args.append(create_arg("dde2", dde2_type, dde2_ndim)) %}
{%- endif %}
{%- if have_die1 %}
{%- do kernel_args.append(create_arg("die1", die1_type, die1_ndim)) %}
{%- endif %}
{%- if have_base_vis %}
{%- do kernel_args.append(create_arg("base_vis", base_vis_type, base_vis_ndim)) %}
{%- endif %}
{%- if have_die2 %}
{%- do kernel_args.append(create_arg("die2", die2_type, die2_ndim)) %}
{%- endif %}

{%- do kernel_args.append(create_arg("output", out_type, out_ndim, False)) %}
{# End kernel argument list construction #}


{%- set have_ddes = have_dde1 and have_dde2 %}
{%- set have_dies = have_die1 and have_die2 %}

{#- Determine nrow and nchan variables #}
{%- if have_ddes %}
{%- set ntime = "dde1.shape()[1]" %}
{%- set na = "dde1.shape()[2]" %}
{%- set nchan = "dde1.shape()[3]" %}
{%- elif have_dies %}
{%- set ntime = "die1.shape()[0]" %}
{%- set na = "die1.shape()[1]" %}
{%- set nchan = "die1.shape()[2]" %}
{%- elif have_coh %}
{%- set nchan = "source_coh.shape()[2]" %}
{%- endif %}

{%- set nrow = "time_index.shape()[0]" %}
{#- end nrow and nchan variable determination #}

{#- Determine nsrc variable #}
{%- set do_coherencies = have_ddes or have_coh %}
{%- if have_ddes %}
{%- set nsrc = "dde1.shape()[0]" %}
{%- elif have_coh %}
{%- set nsrc = "source_coh.shape()[0]" %}
{%- endif %}
{#- End nsrc variable determination #}

{%- set nwarps = (blockdimy*blockdimx + warp_size - 1) // warp_size %}
{%- if nwarps > warp_size %}
{{ throw("A single warp is insufficient to handle the block reduction "
         "of the minimum time index. Code needs to be improved. ") }}
{%- endif %}


// Used to convert between complex trove arrays of different types
template <typename U, typename T>
__device__ __forceinline__
trove::array<U, {{corrs}}>
assign(const trove::array<T, {{corrs}}> & src)
{
    trove::array<U, {{corrs}}> dest;

    {%- for c in range(corrs) %}
    trove::get<{{c}}>(dest).x = trove::get<{{c}}>(src).x;
    trove::get<{{c}}>(dest).y = trove::get<{{c}}>(src).y;
    {%- endfor %}

    return std::move(dest);
}

// Handle warp convergence/non-convergence cases
template <int corrs, typename T>
__device__ __forceinline__
trove::array<T, {{corrs}}>
trove_load(const T * ptr, int i)
{
    if(!trove::warp_converged())
        { return trove::load_array<{{corrs}}>(ptr, i); }

    return trove::load_array_warp_contiguous<{{corrs}}>(ptr, i);
}

template <int corrs, typename T>
__device__ __forceinline__
trove::array<T, {{corrs}}>
trove_store(T * ptr, int i, const trove::array<T, {{corrs}}> & data)
{
    if(!trove::warp_converged())
        { trove::store_array(ptr, i, data); }

    trove::store_array_warp_contiguous(ptr, i, data);
}



template <typename T>
__device__ __forceinline__
void
add_complex_arrays(trove::array<T, {{corrs}}> & dest,
                   const trove::array<T, {{corrs}}> & src)
{
    {%- for c in range(corrs) %}
    trove::get<{{c}}>(dest).x += trove::get<{{c}}>(src).x;
    trove::get<{{c}}>(dest).y += trove::get<{{c}}>(src).y;
    {%- endfor %}
}

template <typename T>
__device__ __forceinline__
void multiply_complex_in_place(T & a, const T & b)
{
    /* Copy input a. */
    T a1 = a;

    /* Multiply complex numbers: a = a * b. */
    a.x *= b.x;
    a.y = a1.x * b.y;
    a.x -= a1.y * b.y; /* RE*RE - IM*IM */
    a.y += a1.y * b.x; /* RE*IM + IM*RE */
}

template <typename T>
__device__ __forceinline__
void multiply_complex_conjugate_in_place(T & a, const T & b)
{
    /* Copy input a. */
    T a1 = a;

    /* Multiply complex numbers: a = a * conjugate(b). */
    a.x *= b.x;
    a.y = a1.y * b.x;
    a.x += a1.y * b.y; /* RE*RE + IM*IM */
    a.y -= a1.x * b.y; /* IM*RE - RE*IM */
}


template <typename T>
__device__ __forceinline__
void multiply_complex(T & out, const T & a, const T & b)
{
    out.x = a.x * b.x;
    out.y = a.x * b.y;
    out.x -= a.y * b.y; /* RE*RE - IM*IM */
    out.y += a.y * b.x; /* RE*IM + IM*RE */
}

template <typename T>
__device__ __forceinline__
void multiply_complex_conjugate(T & out, const T & a, const T & b)
{
    /* Multiply complex numbers a and conjugate(b). */
    out.x = a.x * b.x;
    out.y = a.y * b.x;
    out.x += a.y * b.y; /* RE*RE + IM*IM */
    out.y -= a.x * b.y; /* IM*RE - RE*IM */
}

// More intuitive indexing for trove gets
constexpr int A = 0;
constexpr int B = 1;
constexpr int C = 2;
constexpr int D = 3;

template <typename T>
__device__ __forceinline__
void multiply_complex_matrix_in_place(trove::array<T, {{corrs}}> & m1,
                                      const trove::array<T, {{corrs}}> & m2)
{
    {%- if corrs == 4 %}
    // Copy a and c from the target matrix.
    T t;
    T a = trove::get<A>(m1);   // a1
    T c = trove::get<C>(m1);   // c1;

    multiply_complex_in_place(trove::get<A>(m1), trove::get<A>(m2)); /* a = a1 a2 + b1 c2 */
    multiply_complex(t, trove::get<B>(m1), trove::get<C>(m2));
    trove::get<A>(m1).x += t.x;
    trove::get<A>(m1).y += t.y;

    multiply_complex_in_place(trove::get<C>(m1), trove::get<A>(m2)); /* c = c1 a2 + d1 c2 */
    multiply_complex(t, trove::get<D>(m1), trove::get<C>(m2));
    trove::get<C>(m1).x += t.x; /* Real part. */
    trove::get<C>(m1).y += t.y; /* Imag part. */

    multiply_complex_in_place(trove::get<B>(m1), trove::get<D>(m2)); /* b = a1 b2 + b1 d2 */
    multiply_complex(t, a, trove::get<B>(m2));
    trove::get<B>(m1).x += t.x;
    trove::get<B>(m1).y += t.y;

    multiply_complex_in_place(trove::get<D>(m1), trove::get<D>(m2)); /* d = c1 b2 + d1 d2 */
    multiply_complex(t, c, trove::get<B>(m2));
    trove::get<D>(m1).x += t.x;
    trove::get<D>(m1).y += t.y;

    {%- elif corrs == 2 %}
    multiply_complex_in_place(trove::get<A>(m1), trove::get<A>(m2));
    multiply_complex_in_place(trove::get<B>(m1), trove::get<B>(m2));

    {%- elif corrs == 1 %}
    multiply_complex_in_place(trove::get<A>(m1), trove::get<A>(m2));

    {%- else %}
    {{ throw("Correlations (%d) must be in (4, 2, 1)" % corrs)}}
    {%- endif %}
}

template <typename T>
__device__ __forceinline__
void multiply_complex_matrix_conjugate_transpose_in_place(
    trove::array<T, {{corrs}}> & m1,
    const trove::array<T, {{corrs}}> & m2)
{
    {%- if corrs == 4 %}
    // Copy a and c from the target matrix.
    T t;
    T a = trove::get<A>(m1);   // a1
    T c = trove::get<C>(m1);   // c1;

    /* First, evaluate result a. */
    multiply_complex_conjugate_in_place(trove::get<A>(m1), trove::get<A>(m2));
    multiply_complex_conjugate(t, trove::get<B>(m1), trove::get<B>(m2));
    trove::get<A>(m1).x += t.x; /* Real part. */
    trove::get<A>(m1).y += t.y; /* Imag part. */

    /* Second, evaluate result c. */
    multiply_complex_conjugate_in_place(trove::get<C>(m1), trove::get<A>(m2));
    multiply_complex_conjugate(t, trove::get<D>(m1), trove::get<B>(m2));
    trove::get<C>(m1).x += t.x; /* Real part. */
    trove::get<C>(m1).y += t.y; /* Imag part. */

    /* Third, evaluate result b. */
    multiply_complex_conjugate_in_place(trove::get<B>(m1), trove::get<D>(m2));
    multiply_complex_conjugate(t, a, trove::get<C>(m2));
    trove::get<B>(m1).x += t.x; /* Real part. */
    trove::get<B>(m1).y += t.y; /* Imag part. */

    /* Fourth, evaluate result d. */
    multiply_complex_conjugate_in_place(trove::get<D>(m1), trove::get<D>(m2));
    multiply_complex_conjugate(t, c, trove::get<C>(m2));
    trove::get<D>(m1).x += t.x; /* Real part. */
    trove::get<D>(m1).y += t.y; /* Imag part. */

    {%- elif corrs == 2 %}

    multiply_complex_conjugate_in_place(trove::get<A>(m1), trove::get<A>(m2));
    multiply_complex_conjugate_in_place(trove::get<B>(m1), trove::get<B>(m2));

    {%- elif corrs == 1 %}

    multiply_complex_conjugate_in_place(trove::get<A>(m1), trove::get<A>(m2));

    {%- else %}
    {{ throw("Correlations (%d) must be in (4, 2, 1)" % corrs)}}
    {%- endif %}
}


// If the arguments are in registers this should be a noop
// See https://stackoverflow.com/a/19563246/1611416
template <typename T>
__device__ __forceinline__
void cuda_swap(T & a, T & b)
    { T tmp(a); a = b; b = tmp; }

extern "C" __global__ void {{kernel_name}}(
{{kernel_args|join(",\n")}}
)
{
    int row = blockDim.y*blockIdx.y + threadIdx.y;
    int chan = blockDim.x*blockIdx.x + threadIdx.x;

    // Guard
    // row >= nrow || chan >= nchan
    bool pred = row >= {{nrow}} || chan >= {{nchan}};
    if(pred)
        { return; }

    int time = time_index[row];
    int ant1 = antenna1[row];
    int ant2 = antenna2[row];

    // Work out the minimum time index
    // Shared memory to hold the minimum time index for each warp
    // __shared__ int smin_time[{{nwarps}}];

    // int min_time = time;
    // int bid = blockIdx.y*gridDim.x + blockIdx.x;
    // int tid = threadIdx.y*{{blockdimx}} + threadIdx.x; // Block thread ID
    // int wid = tid / {{warp_size}};                     // Warp ID
    // int lane = tid % {{warp_size}};                    // Lane ID
    // unsigned int mask = __ballot_sync(0xFFFFFFF, !pred);

    // // Compute minimum time index within the warp
    // #pragma unroll
    // for(int offset = {{warp_size // 2}}; offset > 0; offset /= 2)
    // {
    //     int save = min_time;
    //     min_time = min(min_time, __shfl_xor_sync(mask, min_time, offset));
    //     if(row == 66)
    //         { printf("%d, %d %d %d %d %d %d %d\n", mask, bid, tid, row, chan, min_time, save, time); }

    // }

    // // Warp's reduction result lies in lane 0, write to shared memory
    // if(lane == 0)
    //     { smin_time[wid] = min_time; }

    // // Synchronise across the block
    // __syncthreads();

    // // Read minimum time index for each warp in the block
    // min_time = tid < {{nwarps}} ?  smin_time[lane] : 0;

    // // Compute minimum time index within the block
    // #pragma unroll
    // for(int offset = {{warp_size // 2}}; offset > 0; offset /= 2)
    //     { min_time = min(min_time, __shfl_xor_sync(mask, min_time, offset)); }

    // if(tid == 0)
    //     { printf("Current %d vs min %d\n", time, min_time);}

    // Normalise the time index
    // time -= min_time;

    // Declare and initialise result
    typedef trove::array<{{out_type}}, {{corrs}}> vis_type;

    // TODO(sjperkins)
    // A double precision, four correlation kernel uses 80 registers
    // which limits the occupancy of this kernel.
    // It's possible shared memory to hold visibility data and setting
    // "--maxrregcount=64" doubles the possible occupancy of a four correlation
    // double precision kernel.
    // However, the increased shared memory bandwidth triples the execution
    // time, compared to a register only kernel!
    // __shared__ vis_type svis[{{blockdimy}}][{{blockdimx}}];
    // vis_type & vis = svis[threadIdx.y][threadIdx.x];
    vis_type vis;

    {%- if have_base_vis %}
    {
        // Load in base visibility term
        int i = row*{{nchan}} + chan;
        vis = assign<{{out_type}}>(trove_load<{{corrs}}>(&base_vis[0], i));
    }
    {%- else %}
    {%- for c in range(corrs) %}
    trove::get<{{c}}>(vis) = make_{{out_type}}(0.0, 0.0);
    {%- endfor %}
    {%- endif %}


    {% if do_coherencies %}
    // Loop over nsrc
    for(int src=0; src < {{nsrc}}; ++src)
    {
        trove::array<{{out_type}}, {{corrs}}> scratch;

        {%- if have_ddes %}
        {
            // Load in first direction dependent effect term
            int i = (((src*{{ntime}} + time)*{{na}} + ant1)*{{nchan}} + chan)*{{corrs}};
            scratch = assign<{{out_type}}>(trove_load<{{corrs}}>(&dde1[0], i));
        }
        {%- endif %}


        {%- if have_coh %}
        {
            // Load in source coherency term
            int i = (((src*{{nrow}}) + row)*{{nchan}} + chan)*{{corrs}};
            {%- if have_ddes %}
            vis_type coh_term = assign<{{out_type}}>(trove_load<{{corrs}}>(&source_coh[0], i));
            multiply_complex_matrix_in_place(scratch, coh_term);
            {%- else %}
            scratch = assign<{{out_type}}>(trove_load<{{corrs}}>(&source_coh[0], i));
            {%- endif %}
        }
        {%- endif %}


        {%- if have_ddes %}
        {
            // Load in second direction dependent effect term
            int i = (((src*{{ntime}} + time)*{{na}} + ant2)*{{nchan}} + chan)*{{corrs}};
            vis_type dde2_term = assign<{{out_type}}>(trove_load<{{corrs}}>(&dde2[0], i));
            multiply_complex_matrix_conjugate_transpose_in_place(scratch, dde2_term);
        }
        {%- endif %}


        add_complex_arrays(vis, scratch);
    }
    {%- endif %}


    {%- if have_dies %}
    {
        // Load in second direction independent effect term
        int i = ((time*{{na}} + ant2)*{{nchan}} + chan)*{{corrs}};
        vis_type die2_term = assign<{{out_type}}>(trove_load<{{corrs}}>(&die2[0], i));
        multiply_complex_matrix_conjugate_transpose_in_place(vis, die2_term);
    }
    {%- endif %}

    {%- if have_dies %}
    {
        // Load in second direction independent effect term
        int i = ((time*{{na}} + ant1)*{{nchan}} + chan)*{{corrs}};
        vis_type die1_term = assign<{{out_type}}>(trove_load<{{corrs}}>(&die1[0], i));
        cuda_swap(vis, die1_term);
        multiply_complex_matrix_in_place(vis, die1_term);
    }
    {%- endif %}

    // Write out the visibilities
    trove_store<{{corrs}}>(&output[0], (row*{{nchan}} + chan)*{{corrs}}, vis);
}

// jinja2 parameters
// dde1: {{have_dde1}} {{dde1_type}} {{dde1_ndim}}
// source_coh: {{have_coh}} {{coh_type}} {{coh_ndim}}
// have_ddes2 = {{have_dde2}}
// have_dies1 = {{have_die1}}
// have_base_vis = {{have_base_vis}}
// have_dies2 = {{have_die2}}
