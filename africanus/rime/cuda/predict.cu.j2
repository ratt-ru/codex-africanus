#include <cupy/carray.cuh>

{%- macro create_arg(name, type, dims, input=True) -%}
{%- if input %}const{% endif %} CArray<{{type}}, {{dims}}> {{name}}
{%- endmacro -%}

{#- Construct the kernel argument list #}
{%- set kernel_args = [
    create_arg("time_index", "int", 1),
    create_arg("antenna1", "int", 1),
    create_arg("antenna2", "int", 1) ] -%}

{%- if have_dde1 %}
{%- do kernel_args.append(create_arg("dde1", dde1_type, dde1_ndim)) %}
{%- endif %}
{%- if have_coh %}
{%- do kernel_args.append(create_arg("source_coh", coh_type, coh_ndim)) %}
{%- endif %}
{%- if have_dde2 %}
{%- do kernel_args.append(create_arg("dde2", dde2_type, dde2_ndim)) %}
{%- endif %}
{%- if have_die1 %}
{%- do kernel_args.append(create_arg("die1", die1_type, die1_ndim)) %}
{%- endif %}
{%- if have_base_vis %}
{%- do kernel_args.append(create_arg("base_vis", base_vis_type, base_vis_ndim)) %}
{%- endif %}
{%- if have_die2 %}
{%- do kernel_args.append(create_arg("die2", die2_type, die2_ndim)) %}
{%- endif %}

{%- do kernel_args.append(create_arg("output", out_type, out_ndim, False)) %}
{# End kernel argument list construction #}


{%- set have_ddes = have_dde1 and have_dde2 %}
{%- set have_dies = have_die1 and have_die2 %}

{#- Determine nrow and nchan variables #}
{%- if have_ddes %}
{%- set ntime = "dde1.shape()[1]" %}
{%- set na = "dde1.shape()[2]" %}
{%- set nchan = "dde1.shape()[3]" %}
{%- elif have_dies %}
{%- set ntime = "die1.shape()[0]" %}
{%- set na = "die1.shape()[1]" %}
{%- set nchan = "die1.shape()[2]" %}
{%- elif have_coh %}
{%- set nchan = "source_coh.shape()[2]" %}
{%- endif %}

{%- set nrow = "time_index.shape()[0]" %}
{#- end nrow and nchan variable determination #}

{#- Determine nsrc variable #}
{%- set do_coherencies = have_ddes or have_coh %}
{%- if have_ddes %}
{%- set nsrc = "dde1.shape()[0]" %}
{%- elif have_coh %}
{%- set nsrc = "source_coh.shape()[0]" %}
{%- endif %}
{#- End nsrc variable determination #}

{%- set nwarps = (blockdimy*blockdimx + warp_size - 1) // warp_size %}
{%- if nwarps > warp_size %}
{{ throw("A single warp is insufficient to handle the block reduction "
         "of the minimum time index. Code needs to be improved. ") }}
{%- endif %}


{% set corr_names = ['a', 'b', 'c', 'd'][:corrs] %}


template <typename T>
struct vis_type {
{%- for c in corr_names %}
    T {{c}};
{%- endfor %}
};


// Used to convert between complex trove arrays of different types
template <typename U, typename T>
__device__ __forceinline__
vis_type<U>
assign(const vis_type<T> & src)
{
    vis_type<U> dest;

    {%- for c in corr_names %}
    dest.{{c}}.x = src.{{c}}.x;
    dest.{{c}}.y = src.{{c}}.y;
    {%- endfor %}

    return std::move(dest);
}


template <typename T>
__device__ __forceinline__
void multiply_complex_in_place(T & a, const T & b)
{
    T a1 = a;

    a.x *= b.x;
    a.y = a1.x * b.y;
    a.x -= a1.y * b.y;
    a.y += a1.y * b.x;
}

template <typename T>
__device__ __forceinline__
void multiply_complex_conjugate_in_place(T & a, const T & b)
{
    T a1 = a;

    a.x *= b.x;
    a.y = a1.y * b.x;
    a.x += a1.y * b.y;
    a.y -= a1.x * b.y;
}


template <typename T>
__device__ __forceinline__
void multiply_complex(T & out, const T & a, const T & b)
{
    out.x = a.x * b.x;
    out.y = a.x * b.y;
    out.x -= a.y * b.y;
    out.y += a.y * b.x;
}

template <typename T>
__device__ __forceinline__
void multiply_complex_conjugate(T & out, const T & a, const T & b)
{
    out.x = a.x * b.x;
    out.y = a.y * b.x;
    out.x += a.y * b.y;
    out.y -= a.x * b.y;
}

template <typename T>
__device__ __forceinline__
void multiply_complex_matrix_in_place(vis_type<T> & m1,
                                      const vis_type<T> & m2)
{
    {%- if corrs == 4 %}
    // Copy a and c from the target matrix.
    T t;
    T a = m1.a;   // a1
    T c = m1.c;   // c1;

    multiply_complex_in_place(m1.a, m2.a); // a = a1 a2 + b1 c2
    multiply_complex(t, m1.b, m2.c);
    m1.a.x += t.x;
    m1.a.y += t.y;

    multiply_complex_in_place(m1.c, m2.a); // c = c1 a2 + d1 c2
    multiply_complex(t, m1.d, m2.c);
    m1.c.x += t.x;
    m1.c.y += t.y;

    multiply_complex_in_place(m1.b, m2.d); // b = a1 b2 + b1 d2
    multiply_complex(t, a, m2.b);
    m1.b.x += t.x;
    m1.b.y += t.y;

    multiply_complex_in_place(m1.d, m2.d); // d = c1 b2 + d1 d2
    multiply_complex(t, c, m2.b);
    m1.d.x += t.x;
    m1.d.y += t.y;

    {%- elif corrs == 2 %}
    multiply_complex_in_place(m1.a, m2.a);
    multiply_complex_in_place(m1.b, m2.b);

    {%- elif corrs == 1 %}
    multiply_complex_in_place(m1.a, m2.a);

    {%- else %}
    {{ throw("Correlations (%d) must be in (4, 2, 1)" % corrs)}}
    {%- endif %}
}

template <typename T>
__device__ __forceinline__
void multiply_complex_matrix_conjugate_transpose_in_place(
    vis_type<T> & m1,
    const vis_type<T> & m2)
{
    {%- if corrs == 4 %}
    // Copy a and c from the target matrix.
    T t;
    T a = m1.a;   // a1
    T c = m1.c;   // c1;

    multiply_complex_conjugate_in_place(m1.a, m2.a);
    multiply_complex_conjugate(t, m1.b, m2.b);
    m1.a.x += t.x;
    m1.a.y += t.y;


    multiply_complex_conjugate_in_place(m1.c, m2.a);
    multiply_complex_conjugate(t, m1.d, m2.b);
    m1.c.x += t.x;
    m1.c.y += t.y;


    multiply_complex_conjugate_in_place(m1.b, m2.d);
    multiply_complex_conjugate(t, a, m2.c);
    m1.b.x += t.x;
    m1.b.y += t.y;


    multiply_complex_conjugate_in_place(m1.d, m2.d);
    multiply_complex_conjugate(t, c, m2.c);
    m1.d.x += t.x;
    m1.d.y += t.y;

    {%- elif corrs == 2 %}
    multiply_complex_conjugate_in_place(m1.a, m2.a);
    multiply_complex_conjugate_in_place(m1.b, m2.b);

    {%- elif corrs == 1 %}

    multiply_complex_conjugate_in_place(m1.a, m2.a);

    {%- else %}
    {{ throw("Correlations (%d) must be in (4, 2, 1)" % corrs)}}
    {%- endif %}
}


// If the arguments are in registers this should be a noop
// See https://stackoverflow.com/a/19563246/1611416
template <typename T>
__device__ __forceinline__
void cuda_swap(T & a, T & b)
    { T tmp(a); a = b; b = tmp; }

extern "C" __global__ void {{kernel_name}}(
{{kernel_args|join(",\n")}}
)
{
    int row = blockDim.y*blockIdx.y + threadIdx.y;
    int chan = blockDim.x*blockIdx.x + threadIdx.x;

    // Guard
    // row >= nrow || chan >= nchan
    if(row >= {{nrow}} || chan >= {{nchan}})
        { return; }

    int time = time_index[row];
    int ant1 = antenna1[row];
    int ant2 = antenna2[row];

    // Work out the minimum time index
    // Shared memory to hold the minimum time index for each warp
    // __shared__ int smin_time[{{nwarps}}];

    // int min_time = time;
    // int bid = blockIdx.y*gridDim.x + blockIdx.x;
    // int tid = threadIdx.y*{{blockdimx}} + threadIdx.x; // Block thread ID
    // int wid = tid / {{warp_size}};                     // Warp ID
    // int lane = tid % {{warp_size}};                    // Lane ID
    // unsigned int mask = __ballot_sync(0xFFFFFFF, !pred);

    // // Compute minimum time index within the warp
    // #pragma unroll
    // for(int offset = {{warp_size // 2}}; offset > 0; offset /= 2)
    // {
    //     int save = min_time;
    //     min_time = min(min_time, __shfl_xor_sync(mask, min_time, offset));
    //     if(row == 66)
    //         { printf("%d, %d %d %d %d %d %d %d\n", mask, bid, tid, row, chan, min_time, save, time); }

    // }

    // // Warp's reduction result lies in lane 0, write to shared memory
    // if(lane == 0)
    //     { smin_time[wid] = min_time; }

    // // Synchronise across the block
    // __syncthreads();

    // // Read minimum time index for each warp in the block
    // min_time = tid < {{nwarps}} ?  smin_time[lane] : 0;

    // // Compute minimum time index within the block
    // #pragma unroll
    // for(int offset = {{warp_size // 2}}; offset > 0; offset /= 2)
    //     { min_time = min(min_time, __shfl_xor_sync(mask, min_time, offset)); }

    // if(tid == 0)
    //     { printf("Current %d vs min %d\n", time, min_time);}

    // Normalise the time index
    // time -= min_time;

    // Declare and initialise result
    // TODO(sjperkins)
    // A double precision, four correlation kernel uses 80 registers
    // which limits the occupancy of this kernel.
    // It's possible shared memory to hold visibility data and setting
    // "--maxrregcount=64" doubles the possible occupancy of a four correlation
    // double precision kernel.
    // However, the increased shared memory bandwidth triples the execution
    // time, compared to a register only kernel!
    // __shared__ vis_type svis[{{blockdimy}}][{{blockdimx}}];
    // vis_type & vis = svis[threadIdx.y][threadIdx.x];
    typedef vis_type<{{out_type}}> visibility;
    visibility vis;

    {%- if have_base_vis %}
    {
        // Load in base visibility term
        int i = row*{{nchan}} + chan;
        vis = base_vis[i];
    }
    {%- else %}
    {%- for c in corr_names %}
    vis.{{c}} = make_{{out_type}}(0.0, 0.0);
    {%- endfor %}
    {%- endif %}


    {% if do_coherencies %}
    // Loop over nsrc
    for(int src=0; src < {{nsrc}}; ++src)
    {
        vis_type<{{out_type}}> scratch;

        {%- if have_ddes %}
        {
            // Load in first direction dependent effect term
            int i = (((src*{{ntime}} + time)*{{na}} + ant1)*{{nchan}} + chan)*{{corrs}};
            const visibility * ptr = reinterpret_cast<const visibility *>(&dde1[0]);
            scratch = assign<{{out_type}}>(ptr[i]);
        }
        {%- endif %}


        {%- if have_coh %}
        {
            // Load in source coherency term
            int i = (((src*{{nrow}}) + row)*{{nchan}} + chan)*{{corrs}};
            const visibility * ptr = reinterpret_cast<const visibility *>(&source_coh[0]);
            {%- if have_ddes %}
            visibility coh_term = assign<{{out_type}}>(ptr[i]);
            multiply_complex_matrix_in_place(scratch, coh_term);
            {%- else %}
            scratch = assign<{{out_type}}>(ptr[i]);
            {%- endif %}
        }
        {%- endif %}


        {%- if have_ddes %}
        {
            // Load in second direction dependent effect term
            int i = (((src*{{ntime}} + time)*{{na}} + ant2)*{{nchan}} + chan)*{{corrs}};
            const visibility * ptr = reinterpret_cast<const visibility *>(&dde2[0]);
            visibility dde2_term = assign<{{out_type}}>(ptr[i]);
            multiply_complex_matrix_conjugate_transpose_in_place(scratch, dde2_term);
        }
        {%- endif %}


        {%- for c in corr_names %}
        vis.{{c}}.x += scratch.{{c}}.x;
        vis.{{c}}.y += scratch.{{c}}.y;
        {%- endfor %}
    }
    {%- endif %}


    {%- if have_dies %}
    {
        // Load in second direction independent effect term
        int i = ((time*{{na}} + ant2)*{{nchan}} + chan)*{{corrs}};
        const visibility * ptr = reinterpret_cast<const visibility *>(&die2[0]);
        visibility die2_term = assign<{{out_type}}>(ptr[i]);
        multiply_complex_matrix_conjugate_transpose_in_place(vis, die2_term);
    }
    {%- endif %}

    {%- if have_dies %}
    {
        // Load in second direction independent effect term
        int i = ((time*{{na}} + ant1)*{{nchan}} + chan)*{{corrs}};
        const visibility * ptr = reinterpret_cast<const visibility *>(&die1[0]);
        visibility die1_term = assign<{{out_type}}>(ptr[i]);
        cuda_swap(vis, die1_term);
        multiply_complex_matrix_in_place(vis, die1_term);
    }
    {%- endif %}

    {
        // Write out the visibilities
        visibility * ptr = reinterpret_cast<visibility *>(&output[0]);
        ptr[(row*{{nchan}} + chan)*{{corrs}}] = vis;
    }
}

// jinja2 parameters
// dde1: {{have_dde1}} {{dde1_type}} {{dde1_ndim}}
// source_coh: {{have_coh}} {{coh_type}} {{coh_ndim}}
// have_ddes2 = {{have_dde2}}
// have_dies1 = {{have_die1}}
// have_base_vis = {{have_base_vis}}
// have_dies2 = {{have_die2}}
